/**
 * Woz Monitor ROM — 256 bytes at $FF00-$FFFF
 *
 * The Woz Monitor is the built-in firmware of the Apple I computer,
 * written by Steve Wozniak. It provides basic memory examine/deposit
 * commands and program execution via a simple hex-based interface.
 *
 * Key entry points:
 *   $FF00  RESET     — Entry point (CLD, CLI, setup PIA)
 *   $FF1F  NOTCR     — Handle non-CR character during input
 *   $FF2B  NEXTCHAR  — Poll keyboard for next character
 *   $FF40  GETLINE   — Start new input line
 *   $FF43  BACKSPACE — Handle backslash (cancel line indicator)
 *   $FF4C  NEXTITEM  — Parse next item from input buffer
 *   $FF5F  NEXTHEX   — Parse hex digits
 *   $FF73  DIG       — Process a single hex digit
 *   $FF7F  HEXSHIFT  — Shift hex digit into accumulator
 *   $FF8A  NOTHEX    — Handle non-hex character
 *   $FF91  RUN       — JMP indirect through $24-$25 (run user program)
 *   $FF94  NOTSTOR   — Begin examine/dump range
 *   $FFA4  SETADR    — Copy hex value to address pointers
 *   $FFAB  NXTPRNT   — Print next address in dump range
 *   $FFB4  PRDATA    — Print data byte at current address
 *   $FFBA  XRONE     — Increment address, check if done
 *   $FFC7  MODCHK    — Print address on 8-byte boundary
 *   $FFDC  PRBYTE    — Print accumulator as two hex digits
 *   $FFE5  PRHEX     — Print low nibble of accumulator as hex
 *   $FFEF  ECHO      — Output character in A to display
 *
 * Vectors at end of ROM:
 *   $FFFA-$FFFB  NMI vector    → $0F00
 *   $FFFC-$FFFD  RESET vector  → $FF00
 *   $FFFE-$FFFF  IRQ vector    → $0000
 *
 * Reference: https://www.sbprojects.net/projects/apple1/wozmon.php
 */

const ROM_BASE = 0xff00;
const ROM_SIZE = 256;

/** The 256-byte Woz Monitor machine code. */
const WOZ_MONITOR_BYTES: readonly number[] = [
  // $FF00: RESET — CLD, CLI, initialize PIA
  0xd8, 0x58, 0xa0, 0x7f, 0x8c, 0x12, 0xd0, 0xa9,
  0xa7, 0x8d, 0x11, 0xd0, 0x8d, 0x13, 0xd0, 0xc9,
  // $FF10
  0xdf, 0xf0, 0x13, 0xc9, 0x9b, 0xf0, 0x03, 0xc8,
  0x10, 0x0f, 0xa9, 0xdc, 0x20, 0xef, 0xff, 0xa9,
  // $FF20
  0x8d, 0x20, 0xef, 0xff, 0xa0, 0x01, 0x88, 0x30,
  0xf6, 0xad, 0x11, 0xd0, 0x10, 0xfb, 0xad, 0x10,
  // $FF30
  0xd0, 0x99, 0x00, 0x02, 0x20, 0xef, 0xff, 0xc9,
  0x8d, 0xd0, 0xd4, 0xa0, 0xff, 0xa9, 0x00, 0xaa,
  // $FF40
  0x0a, 0x85, 0x2b, 0xc8, 0xb9, 0x00, 0x02, 0xc9,
  0x8d, 0xf0, 0xd4, 0xc9, 0xae, 0x90, 0xf4, 0xf0,
  // $FF50
  0xf0, 0xc9, 0xba, 0xf0, 0xeb, 0xc9, 0xd2, 0xf0,
  0x3b, 0x86, 0x28, 0x86, 0x29, 0x84, 0x2a, 0xb9,
  // $FF60
  0x00, 0x02, 0x49, 0xb0, 0xc9, 0x0a, 0x90, 0x06,
  0x69, 0x88, 0xc9, 0xfa, 0x90, 0x11, 0x0a, 0x0a,
  // $FF70
  0x0a, 0x0a, 0xa2, 0x04, 0x0a, 0x26, 0x28, 0x26,
  0x29, 0xca, 0xd0, 0xf8, 0xc8, 0xd0, 0xe0, 0xc4,
  // $FF80
  0x2a, 0xf0, 0x97, 0x24, 0x2b, 0x50, 0x10, 0xa5,
  0x28, 0x81, 0x26, 0xe6, 0x26, 0xd0, 0xb5, 0xe6,
  // $FF90
  0x27, 0x4c, 0x44, 0xff, 0x6c, 0x24, 0x00, 0x30,
  0x2b, 0xa2, 0x02, 0xb5, 0x27, 0x95, 0x25, 0x95,
  // $FFA0
  0x23, 0xca, 0xd0, 0xf7, 0xd0, 0x14, 0xa9, 0x8d,
  0x20, 0xef, 0xff, 0xa5, 0x25, 0x20, 0xdc, 0xff,
  // $FFB0
  0xa5, 0x24, 0x20, 0xdc, 0xff, 0xa9, 0xba, 0x20,
  0xef, 0xff, 0xa9, 0xa0, 0x20, 0xef, 0xff, 0xa1,
  // $FFC0
  0x24, 0x20, 0xdc, 0xff, 0x86, 0x2b, 0xa5, 0x24,
  0xc5, 0x28, 0xa5, 0x25, 0xe5, 0x29, 0xb0, 0xc1,
  // $FFD0
  0xe6, 0x24, 0xd0, 0x02, 0xe6, 0x25, 0xa5, 0x24,
  0x29, 0x07, 0x10, 0xc8, 0x48, 0x4a, 0x4a, 0x4a,
  // $FFE0
  0x4a, 0x20, 0xe5, 0xff, 0x68, 0x29, 0x0f, 0x09,
  0xb0, 0xc9, 0xba, 0x90, 0x02, 0x69, 0x06, 0x2c,
  // $FFF0
  0x12, 0xd0, 0x30, 0xfb, 0x8d, 0x12, 0xd0, 0x60,
  // $FFF8: padding + vectors
  0x00, 0x00,       // $FFF8-$FFF9: unused
  0x00, 0x0f,       // $FFFA-$FFFB: NMI vector → $0F00
  0x00, 0xff,       // $FFFC-$FFFD: RESET vector → $FF00
  0x00, 0x00,       // $FFFE-$FFFF: IRQ vector → $0000
] as const;

export class WozMonitorROM {
  private readonly data: readonly number[];

  constructor() {
    this.data = WOZ_MONITOR_BYTES;
  }

  /** Returns true if the address falls within the ROM range ($FF00-$FFFF). */
  static inRange(address: number): boolean {
    return address >= ROM_BASE && address <= ROM_BASE + ROM_SIZE - 1;
  }

  /** Read a byte from the ROM. Address must be in range $FF00-$FFFF. */
  read(address: number): number {
    return this.data[address - ROM_BASE];
  }

  /** ROM size in bytes (always 256). */
  get size(): number {
    return ROM_SIZE;
  }

  /** ROM base address ($FF00). */
  get baseAddress(): number {
    return ROM_BASE;
  }

  /** Reset vector value (address the CPU jumps to on reset). */
  get resetVector(): number {
    return this.data[0xfc] | (this.data[0xfd] << 8);
  }

  /** NMI vector value. */
  get nmiVector(): number {
    return this.data[0xfa] | (this.data[0xfb] << 8);
  }

  /** IRQ vector value. */
  get irqVector(): number {
    return this.data[0xfe] | (this.data[0xff] << 8);
  }
}
